// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useState, useEffect } from 'react';
// import MultiStreamsMixer from 'multistreamsmixer';

import {
  Form,
  FormField,
  SpaceBetween,
  Container,
  Button,
  Input,
  Header,
  ColumnLayout,
} from '@awsui/components-react';
import '@awsui/global-styles/index.css';
import useWebSocket from 'react-use-websocket';

import useAppContext from '../../contexts/app';

const WSS_ENDPOINT = 'wss://d59lqabyazbry.cloudfront.net/api/v1/ws';
// const WSS_ENDPOINT = 'ws://127.0.0.1:8080/api/v1/ws';

/* const pcmEncode = (input) => {
  const buffer = new ArrayBuffer(input.length * 2);
  const view = new DataView(buffer);
  for (let i = 0; i < input.length; i += 1) {
    const s = Math.max(-1, Math.min(1, input[i]));
    view.setInt16(i * 2, s < 0 ? s * 0x8000 : s * 0x7fff, true);
  }
  return buffer;
}; */

let mediaRecorder;
// let tempBlob = new Blob();

const StreamAudio = () => {
  const { currentSession } = useAppContext();
  const JWT_TOKEN = currentSession.getAccessToken().getJwtToken();
  const [dataUrl, setDataUrl] = useState('');

  const [callMetaData, setCallMetaData] = useState({
    callId: crypto.randomUUID(),
    agentId: 'AudioStream',
    fromNumber: '+9165551234',
    toNumber: '+8001112222',
    samplingRate: 48000,
    shouldRecordCall: true,
  });
  const [recording, setRecording] = useState(false);

  const { sendMessage } = useWebSocket(WSS_ENDPOINT, {
    queryParams: {
      authorization: `Bearer ${JWT_TOKEN}`,
    },
    onOpen: () => {
      console.log('websocket opened');
    },
    onClose: (event) => {
      console.log(event);
      setRecording(false);
    },
    onError: (event) => {
      console.log(event);
      setRecording(false);
    },
  });

  const handleCallIdChange = (e) => {
    setCallMetaData({
      ...callMetaData,
      callId: e.detail.value,
    });
  };

  const handleAgentIdChange = (e) => {
    setCallMetaData({
      ...callMetaData,
      agentId: e.detail.value,
    });
  };

  const handlefromNumberChange = (e) => {
    setCallMetaData({
      ...callMetaData,
      fromNumber: e.detail.value,
    });
  };

  const handletoNumberChange = (e) => {
    setCallMetaData({
      ...callMetaData,
      toNumber: e.detail.value,
    });
  };

  const floatTo16BitPCM = (input) => {
    const output = new Int16Array(input.length);
    for (let i = 0; i < input.length; i += 1) {
      const s = Math.max(-1, Math.min(1, input[i]));
      output[i] = s < 0 ? s * 0x8000 : s * 0x7fff;
    }
    return output;
  };

  const decodeWebMToAudioBuffer = async (arrayBuffer, audioContext = new AudioContext()) => {
    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

    const left32Bit = audioBuffer.getChannelData(0);
    const right32Bit = audioBuffer.getChannelData(1);
    const left16Bit = floatTo16BitPCM(left32Bit);
    const right16Bit = floatTo16BitPCM(right32Bit);
    const length = left16Bit.length + right16Bit.length;
    const interleaved = new Int16Array(length);

    for (let i = 0, j = 0; i < length; j += 1) {
      interleaved[(i += 1)] = left16Bit[j];
      interleaved[(i += 1)] = right16Bit[j];
    }

    return interleaved;
  };

  const stopRecording = async () => {
    // console.log(`total blob length: ${tempBlob.size}`);

    /* const pcmFloat = await decodeWebMToAudioBuffer(tempBlob);
    const pcm = new Blob([pcmFloat.buffer], { type: 'application/octet-stream' });
    const imageUrl = URL.createObjectURL(pcm); */
    setDataUrl('none');

    if (mediaRecorder) {
      mediaRecorder.stop();
      /* mediaRecorder.port.postMessage({
        message: 'UPDATE_RECORDING_STATE',
        setRecording: false,
      });
      mediaRecorder.port.close();
      mediaRecorder.disconnect(); */
    } else {
      console.log('no media recorder available to stop');
    }
  };

  const convertToMono = (inputStream) => {
    const audioContext = new AudioContext();
    const source = audioContext.createMediaStreamSource(inputStream);
    const merger = audioContext.createChannelMerger(1);
    source.connect(merger, 0, 0);
    source.connect(merger, 0, 0);
    const destination = audioContext.createMediaStreamDestination();
    merger.connect(destination);

    return destination.stream;
  };

  const mergeStreams = (stream1, stream2) => {
    const audioContext = new AudioContext();
    const merger = audioContext.createChannelMerger(2);

    const source1 = audioContext.createMediaStreamSource(stream1);
    const source2 = audioContext.createMediaStreamSource(stream2);

    source1.connect(merger, 0, 0);
    source2.connect(merger, 0, 1);

    const destination = audioContext.createMediaStreamDestination();
    merger.connect(destination);

    return destination.stream;
  };

  const startRecording = async () => {
    try {
      const audioContext = new window.AudioContext();

      const stream1 = await window.navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: true,
      });
      const stream2 = await window.navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true,
      });

      const stream1mono = await convertToMono(stream1);
      const stream2mono = await convertToMono(stream2);
      const mergedStream = mergeStreams(stream1mono, stream2mono);

      const recordingprops = {
        numberOfChannels: 2,
        sampleRate: audioContext.sampleRate,
        maxFrameCount: (audioContext.sampleRate * 1) / 10,
      };

      console.log(`Sample rate: ${audioContext.sampleRate}`);

      setCallMetaData({
        ...callMetaData,
        samplingRate: recordingprops.sampleRate,
      });
      console.log('sending initial metadata:');
      sendMessage(JSON.stringify(callMetaData));

      mediaRecorder = new MediaRecorder(mergedStream, {
        mimeType: 'audio/webm; codecs=pcm',
      });

      mediaRecorder.ondataavailable = async (event) => {
        mediaRecorder.stop();
        // console.log(`On Data Size: ${event.data.size}`);
        const arrayBuffer = await event.data.arrayBuffer();

        try {
          const pcm = await decodeWebMToAudioBuffer(arrayBuffer, audioContext);
          sendMessage(pcm);
        } catch (error) {
          console.log(error);
          mediaRecorder.stop();
        }

        /* this will keep buffering the tempblob */
        /* const newBlob = new Blob([tempBlob, event.data], {
          type: event.data.type,
        });
        tempBlob = newBlob; */
      };

      mediaRecorder.start(100);
    } catch (error) {
      alert(`An error occurred while recording: ${error}`);
      mediaRecorder.stop();
      // await stopRecording();
    }
  };

  /* async function toggleRecording() {
    console.log('toggle recording');
    if (recording) {
      console.log('startRecording');
      await startRecording();
    } else {
      console.log('stopRecording');
      await stopRecording();
    }
  } */

  useEffect(() => {
    // toggleRecording();
  }, [recording]);

  const handleRecording = () => {
    setRecording(!recording);
    if (recording) {
      console.log('Stopping transcription');
      stopRecording();
    } else {
      console.log('Starting transcription');
      startRecording();
    }
    return recording;
  };

  return (
    <form onSubmit={(e) => e.preventDefault()}>
      <Form
        actions={
          <SpaceBetween direction="horizontal" size="xs">
            <Button variant="primary" onClick={handleRecording}>
              {recording ? 'Stop Streaming' : 'Start Streaming'}
            </Button>
            <a href={dataUrl}>Download</a>
          </SpaceBetween>
        }
      >
        <Container header={<Header variant="h2">Call Metadata</Header>}>
          <ColumnLayout columns={2}>
            <FormField label="Call ID" stretch required description="Auto-enerated Unique call ID">
              <Input value={callMetaData.callId} onChange={handleCallIdChange} />
            </FormField>
            <FormField label="Agent ID" stretch required description="Unique Agent ID">
              <Input value={callMetaData.agentId} onChange={handleAgentIdChange} />
            </FormField>
            <FormField label="Customer Phone" stretch required description="Customer Phone">
              <Input value={callMetaData.fromNumber} onChange={handlefromNumberChange} />
            </FormField>
            <FormField label="System Phone" stretch required description="System Phone">
              <Input value={callMetaData.toNumber} onChange={handletoNumberChange} />
            </FormField>
          </ColumnLayout>
        </Container>
      </Form>
    </form>
  );
};

export default StreamAudio;
